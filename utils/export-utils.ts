import moment from "moment/moment";
import { number } from "prop-types";
import { getRemoteDays, RemoteDay } from "./remote-days";
import { createEvents, EventAttributes } from "ics";

export const getSequenceNumber = () => {
  /*const currentDate = new Date();
  const digit = currentDate.getUTCFullYear() % 10;
  return Number(digit + moment(new Date()).format("MMDDHHmm"));*/
  return 0;
};

export const generateEventUid = (date: Date, weekSequence: number) => {
  return "RD" + date.getFullYear() + moment(date).week() + weekSequence + "@sibsrwp";
};

export const getDateArray = (date: Date): [number, number, number, number, number] => {
  return [
    date.getUTCFullYear(),
    date.getUTCMonth() + 1,
    date.getUTCDate(),
    date.getUTCHours(),
    date.getUTCMinutes(),
  ];
};

export const getICSFileContent = (remoteDays: RemoteDay[], group: string, team: string) => {
  const teamUpperCase = team.toUpperCase();
  const events: EventAttributes[] = remoteDays.map(
    (remoteDay): EventAttributes => ({
      method: "REQUEST",
      productId: "jodaros/rwp",
      calName: `Remote Days - ${teamUpperCase} G${group}`,
      title: "Remote Work Day",
      start: getDateArray(remoteDay.date),
      created: getDateArray(new Date()),
      lastModified: getDateArray(new Date()),
      sequence: getSequenceNumber(),
      duration: { hours: 1 },
      description: `Team ${teamUpperCase}\nGroup ${group}\nGenerated by https://sibs-rwp.vercel.app`,
      categories: ["Remote work days"],
      busyStatus: "FREE",
      status: "CONFIRMED",
      uid: generateEventUid(remoteDay.date, remoteDay.weekSequence),
    })
  );
  const { error, value } = createEvents(events);
  if (error) {
    console.log("Error while generating file:", error);
  }
  return value;
};

export const getRemoteDaysForPeriod = (
  group: string,
  startDate: Date,
  endDate: Date,
  initialState: number[],
  initialWeek: Date,
  remoteWeeks: number[][]
) => {
  let remoteDays: RemoteDay[] = [];

  let auxDate = startDate;
  while (auxDate <= endDate) {
    remoteDays.push(...getRemoteDays(auxDate, group, initialState, initialWeek, remoteWeeks));
    auxDate = new Date(auxDate.getFullYear(), auxDate.getMonth() + 1, 1);
  }

  return remoteDays
    .filter(
      (remoteDay, index, self) =>
        self.findIndex((rd) => rd.date.getTime() === remoteDay.date.getTime()) === index
    )
    .filter((remoteDay) => moment(remoteDay.date).isBetween(startDate, endDate, "day", "[]"));
};
